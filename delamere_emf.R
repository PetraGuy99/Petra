setwd('C:/dev/code/Petra')

#analysis of the Delamere eDNA data.
#But here - I filter ONLY the emf data to see when you have a smaller 
#set of species - do we get the same answers?

library(readxl)
library(vegan)
library(tidyr)
library(dplyr)
library(ggplot2)
library(VennDiagram)


#load the read data
allreads = read_xlsx('../../data/DelamereData.xlsx', sheet = 'SppSite')

#remove the transect data from this
#cols D0A:F3C, and delete col 99, the taxon detail column.
reads = allreads[,-c(40:75,135)] # just the Delamere pilot study data


################################################################################
#create a rarefied data frame - in case we want to do any diversity analysis!
#vegan assumes rows are samples and cols are species - site/species, need to transpose the data
reads_mat <- as.matrix(reads[, -1])   # remove Taxonomy column
rownames(reads_mat) <- reads$Taxonomy

# Transpose so rows = samples, cols = ASVs
reads_t <- t(reads_mat)
mode(reads_t) <- "numeric"
min_depth <- min(rowSums(reads_t))
rarefied <- rrarefy(reads_t, sample = min_depth)



#check spec acc curve against min read depth
#this outputs the rarefaction curves - i.e. the random resamples of the data 
#generated by randomly resampling each sample until min_depth per sample is reached
#and plotting the species richness 
rarecurve(reads_t, step = 1000, col = "blue", cex = 0.6, xlim = c(1,10000),
          xlab = "Reads per Sample", ylab = "Species Richness")
abline(v = 4218, col = "red", lty = 2, lwd = 2)

################################################################################
#Transpose back so that I can merge with Functional traits etc
# Transpose back to species × samples
rarefied_back <- t(rarefied)

# Convert to data frame for easier export
rarefied_df <- as.data.frame(rarefied_back)

# Add species column as first column
rarefied_df <- tibble::rownames_to_column(rarefied_df, var = "Species")

###############################################################################
#merge with fungal traits
traits = read.csv('../../data/FunctionalTraits.csv')

#some cells are empty rather than NA
traits$primary_lifestyle[traits$primary_lifestyle == ""] <- NA

#split the taxonomy column so can merge by genus
rare.split <- rarefied_df %>%
  separate(Species, into = c("GENUS", "Species"), sep = "_")

fungi.merged = merge(rare.split, traits, by = 'GENUS', all.x = TRUE)

#tidy by deleting unrequired columns
fungi.merged = fungi.merged[,-c(136,137:141,143:157,156:159)]

#explore the total community in all samples
lifestyle_counts <- fungi.merged %>%
  count(primary_lifestyle) %>%
  arrange(desc(n))

#this plot has everything in - i.e. you can see ~ 200 species with NA guild - 
#thats because those are the above guild level and/or spp with no guild found - 
#these are removed later
ggplot(lifestyle_counts, aes(x = reorder(primary_lifestyle, -n), y = n)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  labs(title = "Number of Species per Primary Lifestyle",
       x = "Primary Lifestyle",
       y = "Number of Species") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


#ALSO - NEED THIS DF FOR LATER - SO RUN THIS LINE!!!
checking_df <- fungi.merged %>%
  filter(is.na(primary_lifestyle)) %>%
  select(GENUS, Species, primary_lifestyle)


#save this for checking
checkingdf = write.csv(checking_df,'../../data/checking.csv')

################################################################################

# This section looks at the groups which are or arenot matched to guilds and tries
#to tidy them all up so that most can be grouped, and those matched at family
#and above are removed

#checking all the items with sp in species column. Some are genus level, 
#If a sequence is at same family level, the GENUS column say Theler[horaceae, say
#and Species column says sp.
#For emf at Genus level, the GENUS column says Thelephora, say, and the Species
#column say sp - so looking at the 'sp' in Species column does not isolate emf at
#above genus - needs a bit of work...

#to remove the >genus level matches, take the rows from checking_df 
#where Species column is sp, this has genus level AND above genus level
above_genus = checking_df %>% filter(Species == 'sp') #179

#remove rows from fungi.merged where GENUS&species match above_genus
#this is all fungi with a sp name AND a guild
spp_level_guild = fungi.merged %>%
  filter(Species != "sp", !is.na(primary_lifestyle)) #855

#this is all fungi with a sp name and no guild
species_level_noguild = fungi.merged %>%
  filter(Species != "sp", is.na(primary_lifestyle)) #11

#if there are rows where Species = sp and primary lifestyle NOT NA, then the 
#GENUS column must have been a proper genus name, so that there was a guild match
#other wise the genus column is not a genus name - its above, hence no match
#the are fungi at genus level with a guild
genus_level_guild = fungi.merged %>%
  filter(Species== "sp", !is.na(primary_lifestyle)) #284

#this is BOTH the above genus level fungi AND any that might have been at genus
#level - but the genus was not recognized by Functional Traits
genus_level_noguild = fungi.merged %>%
  filter(Species== "sp", is.na(primary_lifestyle)) #179 

#make df of genus_level_guild + spp_level_guild + species_level_noguild
allfungi = rbind.data.frame(spp_level_guild, species_level_noguild, genus_level_guild)

#tidy this up by removing all the weird cols from Functional Traits merge
allfungi = allfungi[,-c(100:105,107:122,123)]
#This is now the working df - the only items missing will be any at genus level,
#with sp for speices, but no guild match. They can only be found by inspection -
#there were 2

#################################################################################

library(stringr)

#add a column to merge all sapros to sapro rather than the separate types
allfungi$lifestyle <- ifelse(
  str_detect(allfungi$primary_lifestyle, "_"),
  str_extract(allfungi$primary_lifestyle, "(?<=_).*"),
  allfungi$primary_lifestyle
)


#explore the total community in all samples, when the lifestyles are merged
#for simplicity
lifestyle_counts <- allfungi %>%
  count(lifestyle) %>%
  arrange(desc(n))

ggplot(lifestyle_counts, aes(x = reorder(lifestyle, -n), y = n)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  geom_text(aes(label = n), vjust = -0.3) +  # <-- Add labels above bars
  labs(title = "Number of Species per Lifestyle",
       x = "Primary Lifestyle",
       y = "Number of Species") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
###############################################################################

#---------------------------

##Now I will remove the emf only and carry on the analysis as in delamere.R

allfungi_filtered<- allfungi %>%
  filter(lifestyle %in% c("ectomycorrhizal", "mycorrhizal"))
#--------------------------


###############################################################################
#NOW SOME ANALYSIS OF SAMPLING METHODS. WE CAN KEEP EVERYTHING TOGETHER AS A 
#SEPARATE ASV FOR THIS, AND KEEP ALL THE TAXA, NOT YET INTERESTED IN HOW MANY ECTOS 
#ETC...

# 1. SAC over 64 samples in 8m2
#extract the unpooled single samples, the roots and rhizo soil
#col 1 and 2 are genus,species
#run each data file one at a time to get increasing samples, just A, A and pooled, etc
# Define the three datasets
data1 <- allfungi[, c(3:7, 41:99)]               # A samples
data2 <- allfungi[, c(3:22, 41:99)]              # pooled + repeat aliquots
data3 <- allfungi[, -c(1:2, 100:124)]            # everything (roots and rhizo)

# Make presence/absence
data1[data1 > 0] <- 1
data2[data2 > 0] <- 1
data3[data3 > 0] <- 1

# Calculate SACs (transpose since vegan expects sites as rows)
sac1 <- specaccum(t(data1), method = "random")
sac2 <- specaccum(t(data2), method = "random")
sac3 <- specaccum(t(data3), method = "random")

# Convert each to a dataframe and label
df1 <- data.frame(Samples = sac1$sites, Richness = sac1$richness, SD = sac1$sd, Group = "A samples")
df2 <- data.frame(Samples = sac2$sites, Richness = sac2$richness, SD = sac2$sd, Group = "Pooled + repeats")
df3 <- data.frame(Samples = sac3$sites, Richness = sac3$richness, SD = sac3$sd, Group = "All samples")

# Combine all
sac_df <- bind_rows(df1, df2, df3)

# Plot with ggplot
ggplot(sac_df, aes(x = Samples, y = Richness, color = Group, fill = Group)) +
  geom_line(size = 1.2) +
  geom_ribbon(aes(ymin = Richness - SD, ymax = Richness + SD), alpha = 0.2, colour = NA) +
  labs(
    x = "Number of Samples",
    y = "Cumulative Species Richness",
    title = "Species-Area Curve for Different Sample Sets"
  ) +
  theme_minimal() +
  theme(
    legend.title = element_blank(),
    plot.title = element_text(face = "bold")
  )

################################################################################
#WHAT ABOUT JUST ECTOS
emf <- allfungi %>% filter(lifestyle == 'ectomycorrhizal')

# Subsets
emf_soil       <- emf[, c(3:7, 41:99)]
emf_root       <- emf[, c(32:40)]
emf_rhizo      <- emf[, c(23:31)]
emf_rhizo_root <- emf[, c(23:40)]

# Convert to presence/absence
emf_soil[emf_soil > 0]             <- 1
emf_root[emf_root > 0]             <- 1
emf_rhizo[emf_rhizo > 0]           <- 1
emf_rhizo_root[emf_rhizo_root > 0] <- 1

# Calculate species accumulation curves (transpose: sites as rows for vegan)
sac_soil       <- specaccum(t(emf_soil), method = "random")
sac_root       <- specaccum(t(emf_root), method = "random")
sac_rhizo      <- specaccum(t(emf_rhizo), method = "random")
sac_rhizo_root <- specaccum(t(emf_rhizo_root), method = "random")

# Function to tidy the SAC output
sac_to_df <- function(sac_obj, label) {
  data.frame(
    Sites    = sac_obj$sites,
    Richness = sac_obj$richness,
    SD       = sac_obj$sd,
    Group    = label
  )
}

# Combine into one dataframe
df_all <- rbind(
  sac_to_df(sac_soil,       "Soil"),
  sac_to_df(sac_root,       "Root"),
  sac_to_df(sac_rhizo,      "Rhizosphere"),
  sac_to_df(sac_rhizo_root, "Rhizo + Root")
)

# Plot
ggplot(df_all, aes(x = Sites, y = Richness, color = Group, fill = Group)) +
  geom_line(size = 1.2) +
  geom_ribbon(aes(ymin = Richness - SD, ymax = Richness + SD), alpha = 0.2, linetype = 0) +
  theme_minimal() +
  labs(
    title = "Species–Area Curves for EMF Guild",
    x = "Number of Samples",
    y = "Accumulated Species Richness"
  ) +
  theme(
    legend.title = element_blank(),
    plot.title = element_text(face = "bold")
  )

#######################################################################

#POOLING
#extract the separate samples B1,2,3
allfungi = allfungi_filtered
process_sample_group <- function(pooled_col, single_cols, name) {
  # Get pooled and single sample data
  pooled_df <- allfungi[, c("GENUS", "Species", pooled_col)]
  single_df <- allfungi[, c("GENUS", "Species", single_cols)]
  
  # Combine genus and species
  pooled_df$species <- paste(pooled_df$GENUS, pooled_df$Species, sep = "_")
  single_df$species <- paste(single_df$GENUS, single_df$Species, sep = "_")
  
  # Presence/absence for pooled
  pooled_df$pres <- ifelse(pooled_df[[pooled_col]] > 0, 1, 0)
  
  # Presence/absence for singles
  single_df[single_cols] <- lapply(single_df[single_cols], function(x) ifelse(x > 0, 1, 0))
  
  # SAC for single samples
  sac <- specaccum(t(single_df[single_cols]), method = "random")
  
  # Tidy SAC dataframe
  sac_df <- data.frame(
    Samples = sac$sites,
    Richness = sac$richness,
    SD = sac$sd,
    Group = name
  )
  
  # Unique species in singles
  single_sp_df <- cbind(single_df$species, single_df[single_cols])
  single_sp_df <- as.data.frame(single_sp_df)
  colnames(single_sp_df)[1] <- "species"
  single_sp_df[, -1] <- lapply(single_sp_df[, -1], as.numeric)
  single_filtered <- single_sp_df[!apply(single_sp_df[, -1] == 0, 1, all), ]
  singles_list <- single_filtered$species
  
  # Unique species in pooled
  pooled_list <- pooled_df %>% filter(pres == 1) %>% pull(species)
  
  return(list(
    sac_df = sac_df,
    pooled = pooled_list,
    singles = singles_list
  ))
}

#----------------------------
# Define your groups here
#----------------------------

groups <- list(
  B1 = list(
    pooled_col = "B1",
    single_cols = c("A2", "A3", "A4", "A10","A11","A12","A18","A19","A20")
  ),
  B2 = list(
    pooled_col = "B2",
    single_cols = c("A39", "A40", "A33", "A31","A32","A25","A23","A24","A17")
  ),
  B3 = list(
    pooled_col = "B3",
    single_cols = c("A63", "A62", "A57", "A55","A56","A49","A47","A48","A41")
  )
)

#----------------------------
# Process each group
#----------------------------

sac_all <- list()
venn_lists <- list()

for (g in names(groups)) {
  result <- process_sample_group(
    pooled_col = groups[[g]]$pooled_col,
    single_cols = groups[[g]]$single_cols,
    name = g
  )
  
  sac_all[[g]] <- result$sac_df
  venn_lists[[g]] <- list(Pooled = result$pooled, Singles = result$singles)
}

#----------------------------
# Combine all SACs and plot
#----------------------------

sac_df_combined <- bind_rows(sac_all)

abline_data <- lapply(venn_lists, function(x) length(x$Pooled))
abline_df <- data.frame(Group = names(abline_data), Richness = unlist(abline_data))

# Plot with ablines
ggplot(sac_df_combined, aes(x = Samples, y = Richness, color = Group, fill = Group)) +
  geom_line(size = 1.2) +
  geom_ribbon(aes(ymin = Richness - SD, ymax = Richness + SD), alpha = 0.2, linetype = 0) +
  geom_hline(data = abline_df, aes(yintercept = Richness, color = Group), linetype = "dashed", size = 1) +
  theme_minimal() +
  labs(
    title = "Species-Area Curves for Pooled/unpooled",
    x = "Number of Samples",
    y = "Cumulative Species Richness"
  ) +
  theme(
    legend.title = element_blank(),
    plot.title = element_text(face = "bold")
  ) +
  scale_x_continuous(breaks = scales::pretty_breaks(n = max(sac_df_combined$Samples)))

#----------------------------
# Draw Venn diagrams
#----------------------------

for (g in names(venn_lists)) {
  venn.plot <- venn.diagram(
    x = venn_lists[[g]],
    filename = NULL,
    fill = c("skyblue", "lightgreen"),
    alpha = 0.5,
    cex = 2,
    cat.cex = 1.5,
    cat.pos = 0,
    cat.dist = 0.05,
    main = paste("Species Overlap: Pooled vs Singles,", g)
  )
  grid.newpage()
  grid.draw(venn.plot)
}

library(gridExtra)
library(grid)

# Create and store Venn diagram grobs as proper grobs
venn_grobs <- lapply(names(venn_lists), function(g) {
  venn <- venn.diagram(
    x = venn_lists[[g]],
    filename = NULL,
    fill = c("skyblue", "lightgreen"),
    alpha = 0.5,
    cex = 2,
    cat.cex = 1.5,
    cat.pos = 0,
    cat.dist = 0.05,
    main = paste("Species Overlap: Pooled vs Singles,", g)
  )
  grobTree(venn)  # <— wrap in grobTree to make it compatible
})

# Plot them in a grid
grid.newpage()
grid.arrange(grobs = venn_grobs, ncol = 3)
################################################################################

###########How many species do we generally find in a sample, is a rhizo sample
#as good/better than a soil, or root etc

#first - what is mean richness of a single sample - an A sample
single_samples = ecto_only[,c(3:7,41:99)]
single_samples_pa = single_samples
single_samples_pa = as.data.frame(lapply(single_samples_pa, function(x) ifelse(x>0,1,0)))
single_sample_richness = colSums(single_samples_pa)
single_sample_lable = rep('single',64)
single_samples_df = cbind.data.frame(single_sample_lable, single_sample_richness)
colnames(single_samples_df) = c('group','richness')

#now to pooled, B1,B2,B3 
pooled_samples = ecto_only[,c(14,17,20)]
pooled_samples_pa = pooled_samples
pooled_samples_pa = as.data.frame(lapply(pooled_samples_pa, function(x) ifelse(x>0,1,0)))
pooled_sample_richness = colSums((pooled_samples_pa))
pooled_sample_lable = rep('pooled',3)
pooled_samples_df = cbind.data.frame(pooled_sample_lable, pooled_sample_richness)
colnames(pooled_samples_df) = c('group','richness')

#the roots
roots = ecto_only[,c(32:40)]
roots_pa = roots
roots_pa = as.data.frame(lapply(roots_pa, function(x) ifelse(x>0,1,0)))
roots_sample_lable = rep('root',9)
roots_sample_richness = colSums(roots_pa)
roots_sample_label = rep('roots',9)
roots_df = cbind.data.frame(roots_sample_label, roots_sample_richness)
colnames(roots_df) = c('group','richness')

#the rhizo soil
rhizo = ecto_only[,c(23:31)]
rhizo_pa = rhizo
rhizo_pa = as.data.frame(lapply(rhizo_pa, function(x) ifelse(x>0,1,0)))
rhizo_sample_richness = colSums(rhizo_pa)
rhizo_sample_lable = rep('rhizo',9)
rhizo_df = cbind.data.frame(rhizo_sample_lable, rhizo_sample_richness)
colnames(rhizo_df) = c('group','richness')

df = rbind.data.frame(single_samples_df, pooled_samples_df, roots_df, rhizo_df)

ggplot(df, aes(x = group, y = richness)) +
  geom_boxplot(fill = "lightblue", color = "black") +
  theme_minimal() +
  labs(title = "Species Richness by Group",
       x = "Group",
       y = "Species Richness")

################################################################################

allfungi_pa <- allfungi
allfungi_pa[, -c(1:2, 100:124)] <- lapply(allfungi_pa[, -c(1:2, 100:124)], function(x) ifelse(x > 0, 1, 0))

# Step 2: Calculate species richness per sample (sum of 1s in each column)
sample_richness <- colSums(allfungi_pa[,-c(1:2, 100:124)], na.rm = TRUE)

# Step 3: Plot the distribution of species richness across samples
boxplot(sample_richness,
        main = "Distribution of Species Richness per Sample",
        ylab = "Number of Species",
        col = "lightblue")
sample_richness = colSums(allfungi[c(3:99)])
boxplot(sample_richness,
        main = "Distribution of Species Richness per Sample",
        ylab = "Number of Species",
        col = "lightblue")

#which samples tend to be the richest? Any patterns

sample_data <- allfungi_pa[, -c(1:2, 100:124)]

# Calculate species richness (sum of 1s) per sample
richness <- colSums(sample_data)

# Convert to data frame for plotting
richness_df <- data.frame(
  Sample = names(richness),
  Richness = as.numeric(richness)
)

# Order by richness descending
richness_df <- richness_df[order(-richness_df$Richness), ]

# Plot using ggplot2
library(ggplot2)
ggplot(richness_df, aes(x = reorder(Sample, -Richness), y = Richness)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  theme_minimal() +
  labs(title = "Species Richness per Sample",
       x = "Sample",
       y = "Species Richness") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

################################################################################

#now compare the repeated extracts from a single sample and a pooled sample.
#Is it better to take three separate samples, or do three extracts from the same sample
#What is richness of three Extracts compared to three separate, and how does community overlap

#compare this to taking three separate samples
#look at different combinations of A samples in the area of A12
#A12+A3+A4
#A12+A13+A20
#A12+A21+A5

#compare that to A12,A121, A122

get_species_repeats <- function(df, col1, col2, col3) {
  # Convert column names to symbols if given as strings
  col1 <- rlang::ensym(col1)
  col2 <- rlang::ensym(col2)
  col3 <- rlang::ensym(col3)
  
  # Extract and binarise presence-absence data
  data <- cbind.data.frame(
    col1 = as.integer(df[[as.character(col1)]] > 0),
    col2 = as.integer(df[[as.character(col2)]] > 0),
    col3 = as.integer(df[[as.character(col3)]] > 0)
  )
  
  # Identify unique species at each step
  species_1 <- which(data$col1 == 1)
  species_2_new <- which(data$col2 == 1 & data$col1 == 0)
  species_3_new <- which(data$col3 == 1 & data$col1 == 0 & data$col2 == 0)
  
  # Cumulative counts
  count1 <- length(species_1)
  count2 <- count1 + length(species_2_new)
  count3 <- count2 + length(species_3_new)
  
  # Return vector
  df_out <- c(count1, count2, count3)
  return(df_out)
}

repeatsA12 = get_species_repeats(allfungi, A12, A121, A122)
singlesA12.test1 = get_species_repeats(allfungi,A12, A13, A20)
singlesA12.test2 = get_species_repeats(allfungi,A12, A21, A5)
singlesA12.test3 = get_species_repeats(allfungi,A12, A3, A4)

#now repeat this for A34 and A60
#A34,A341,A342
#A34,A35,A26
#A34,A33,A25
#A34,A42,A43

repeatsA34 = get_species_repeats(allfungi, A34, A341, A342)
singlesA34.test1 = get_species_repeats(allfungi,A34, A35, A26)
singlesA34.test2 = get_species_repeats(allfungi,A34, A33, A25)
singlesA34.test3 = get_species_repeats(allfungi,A34, A42, A43)

#A60,A601,A602
#A60,A61,A52
#A60,A59,A51
#A60,A53,A52

repeatsA60 = get_species_repeats(allfungi, A60, A601, A602)
singlesA60.test1 = get_species_repeats(allfungi,A60, A61, A52)
singlesA60.test2 = get_species_repeats(allfungi,A60, A59, A51)
singlesA60.test3 = get_species_repeats(allfungi,A60, A53, A52)

#make df
repeats_df = cbind.data.frame(repeatsA12,singlesA12.test1,singlesA12.test2,singlesA12.test3,
                              repeatsA34,singlesA34.test1, singlesA34.test2, singlesA34.test3,
                              repeatsA60, singlesA60.test1, singlesA60.test2,singlesA60.test3 )
colnames(repeats_df) = c('A12reps','A12a','A12b','A12c',
                         'A34reps','A34a','A34b','A34c',
                         'A60reps','A60a','A60b','A60c')
repeats_df$sample = c(1,2,3)

special_lines <- c("A12reps", "A34reps", "A60reps")

df_long <- repeats_df %>%
  pivot_longer(
    cols = -sample,
    names_to = "Variable",
    values_to = "Value"
  ) %>%
  mutate(
    ColIndex = as.numeric(factor(Variable, levels = unique(Variable))),
    ChartID = ((ColIndex - 1) %/% 4) + 1,
    LineType = ifelse(Variable %in% special_lines, "dashed", "solid")
  )

ggplot(df_long, aes(x = sample, y = Value, colour = Variable, group = Variable, linetype = LineType)) +
  geom_line(linewidth = 1) +
  facet_wrap(~ ChartID, scales = "free_y") +
  scale_linetype_identity() +
  scale_x_continuous(breaks = scales::pretty_breaks(), labels = as.integer) +
  labs(x = "Number of samples", y = "Cumulative alpha diversity",
       title = "Three examples of taking three separate samples, or 2 additional soil aliquots") +
  theme_minimal() +
  theme(legend.position = "none")  

#Now look at community in repeated aliquots versus repeated samples.
#What is community in A12+A121+A122, compared to community in
##A12+A3+A4
#A12+A13+A20
#A12+A21+A5

library(ggvenn)

fungi_pa <- allfungi
fungi_pa[fungi_pa > 0] <- 1

make_venn_jaccard_heatmap <- function(df, group_list, plot_title = NULL) {
  # Pool species in each group
  pooled_groups <- lapply(group_list, function(samples) {
    spp_present <- rowSums(df[, samples, drop = FALSE]) > 0
    rownames(df)[spp_present]
  })
  
  # Names for venn plot
  names(pooled_groups) <- names(group_list)
  
  # Venn plot
  print(
    ggvenn(
      pooled_groups,
      show_percentage = FALSE,
      set_name_size = 3,
      text_size = 3
    ) + ggtitle(plot_title)
  )
  
  # Prepare presence absence matrix for Jaccard
  all_species <- unique(unlist(pooled_groups))
  to_pa_vector <- function(spp, all_spp) as.numeric(all_spp %in% spp)
  
  pa_matrix <- do.call(rbind, lapply(pooled_groups, to_pa_vector, all_spp = all_species))
  rownames(pa_matrix) <- names(pooled_groups)
  colnames(pa_matrix) <- all_species
  
  # Calculate Jaccard similarity (1 - distance)
  jaccard_sim <- 1 - vegdist(pa_matrix, method = "jaccard", binary = TRUE)
  jaccard_mat <- as.matrix(jaccard_sim)
  
  # Melt for heatmap plotting (lower triangle only)
  jaccard_df <- melt(jaccard_mat)
  colnames(jaccard_df) <- c("Group1", "Group2", "Similarity")
  jaccard_df <- jaccard_df %>%
    filter(as.numeric(factor(Group1)) >= as.numeric(factor(Group2)))
  
  # Heatmap plot
  print(
    ggplot(jaccard_df, aes(x = Group1, y = Group2, fill = Similarity)) +
      geom_tile(color = "white") +
      geom_text(aes(label = round(Similarity, 2)), size = 4) +
      scale_fill_gradient(low = "white", high = "steelblue") +
      theme_minimal() +
      theme(
        axis.text.x = element_text(angle = 45, hjust = 1),
        axis.title = element_blank()
      ) +
      coord_fixed() +
      ggtitle(paste("Jaccard Similarity -", plot_title))
  )
}

# Define your 3 sets of groups

set1 <- list(
  G1_A12reps       = c("A12", "A121", "A122"),
  G2_A12_A13_A20   = c("A12", "A13", "A20"),
  G3_A12_A21_A5    = c("A12", "A21", "A5"),
  G4_A12_A3_A4     = c("A12", "A3", "A4")
)

set2 <- list(
  G1_A60reps       = c("A60", "A601", "A602"),
  G2_A60_A61_A52   = c("A60", "A61", "A52"),
  G3_A60_A59_A51   = c("A60", "A59", "A51"),
  G4_A60_A53_A52   = c("A60", "A53", "A52")
)

set3 <- list(
  G1_A34reps       = c("A34", "A341", "A342"),
  G2_A34_A33_A25   = c("A34", "A33", "A25"),
  G3_A34_A42_A43   = c("A34", "A42", "A43"),
  G3_A34_A35_A26   =c("A34", "A35", "A26")
)

# Run function for each set
make_venn_jaccard_heatmap(fungi_pa, set1, "Set 1: A12 Groups")
make_venn_jaccard_heatmap(fungi_pa, set2, "Set 2: A60 Groups")
make_venn_jaccard_heatmap(fungi_pa, set3, "Set 3: A34 Groups")

#Final comparison for repeated aliquots is the B pooled samples#################
#______________________________________________________________________________#
#How does B1+B12+B13 compare to the set of 9 singles in the same area###########


compare_groups <- function(df, group1_samples, group2_samples, title = "") {
  # Pool species for each group
  group1_species <- rownames(df)[rowSums(df[, group1_samples, drop = FALSE]) > 0]
  group2_species <- rownames(df)[rowSums(df[, group2_samples, drop = FALSE]) > 0]
  
  # Combine species and calculate cumulative totals for plotting
  species_union <- unique(c(group1_species, group2_species))
  
  # For cumulative species plot, order groups and plot cumulative totals
  # Here, just two groups, so cumulative for group1, then cumulative for group1+group2 combined
  
  # cumulative species count in group1
  cum_counts_group1 <- cumsum(sort(unique(group1_species)) %>% length())
  # cumulative species count for combined (group1 + group2)
  cum_counts_combined <- length(species_union)
  
  # Instead, let's do cumulative species by adding samples one by one for each group:
  # So, for group1 samples
  cum_species_counts <- function(samples) {
    species_seen <- c()
    cum_counts <- numeric(length(samples))
    for (i in seq_along(samples)) {
      spp_i <- rownames(df)[df[, samples[i]] == 1]
      species_seen <- unique(c(species_seen, spp_i))
      cum_counts[i] <- length(species_seen)
    }
    cum_counts
  }
  
  cum_group1 <- cum_species_counts(group1_samples)
  cum_group2 <- cum_species_counts(group2_samples)
  
  # Prepare data for ggplot
  df_cum <- data.frame(
    SampleNumber = c(seq_along(cum_group1), seq_along(cum_group2)),
    CumulativeSpecies = c(cum_group1, cum_group2),
    Group = rep(c("Group1", "Group2"), times = c(length(cum_group1), length(cum_group2)))
  )
  
  # Plot cumulative species
  p_cum <- ggplot(df_cum, aes(x = SampleNumber, y = CumulativeSpecies, color = Group)) +
    geom_line(size = 1.2) + geom_point() +
    labs(title = paste("Cumulative species -", title),
         x = "Number of samples",
         y = "Cumulative species count") +
    theme_minimal() +
    scale_color_manual(values = c("Group1" = "blue", "Group2" = "red"))
  
  print(p_cum)
  
  # Venn plot of pooled groups
  venn_data <- list(
    Group1 = group1_species,
    Group2 = group2_species
  )
  print(ggvenn(venn_data, show_percentage = FALSE) + ggtitle(paste("Venn diagram -", title)))
  
  # Jaccard similarity (only 2 groups)
  all_species <- unique(c(group1_species, group2_species))
  to_pa_vector <- function(spp, all_spp) as.numeric(all_spp %in% spp)
  pa_mat <- rbind(
    Group1 = to_pa_vector(group1_species, all_species),
    Group2 = to_pa_vector(group2_species, all_species)
  )
  
  jaccard_sim <- 1 - vegdist(pa_mat, method = "jaccard", binary = TRUE)
  jaccard_mat <- as.matrix(jaccard_sim)
  jaccard_df <- melt(jaccard_mat)
  colnames(jaccard_df) <- c("Group1", "Group2", "Similarity")
  
  # Heatmap plot (2x2 matrix, simple)
  print(
    ggplot(jaccard_df, aes(x = Group1, y = Group2, fill = Similarity)) +
      geom_tile(color = "white") +
      geom_text(aes(label = round(Similarity, 2)), size = 6) +
      scale_fill_gradient(low = "white", high = "steelblue") +
      theme_minimal() +
      theme(axis.title = element_blank(),
            axis.text.x = element_text(angle = 45, hjust = 1)) +
      coord_fixed() +
      ggtitle(paste("Jaccard similarity -", title))
  )
}

# Now define your groups and run the function

# 1st comparison
groupB1 <- c("B1", "B12", "B13")
groupA1 <- c("A2", "A3", "A4", "A10", "A11","A12", "A18", "A19", "A20")

# 2nd comparison
groupB2 <- c("B2", "B22", "B23")
groupA2 <- c("A17", "A23", "A24", "A25", "A31", "A32", "A33", "A39", "A40")

# 3rd comparison
groupB3 <- c("B3", "B32", "B33")
groupA3 <- c("A41", "A47", "A48", "A49", "A55", "A56", "A57", "A62", "A63")

# Run all 3
compare_groups(fungi_pa, groupB1, groupA1, "B1 group vs A1 group")
compare_groups(fungi_pa, groupB2, groupA2, "B2 group vs A2 group")
compare_groups(fungi_pa, groupB3, groupA3, "B3 group vs A3 group")

################################################################################
#Finally, because I know someone will ask!
#Which set of 3 A's is the Bs most similar to?
################################################################################

pool_species <- function(df, samples) {
  spp_present <- rowSums(df[, samples, drop = FALSE]) > 0
  rownames(df)[spp_present]
}

compare_b_vs_a_triplets <- function(df, b_samples, a_samples, b_name = "Bgroup", a_name = "Agroup") {
  # Pool B samples once
  b_species <- pool_species(df, b_samples)
  
  # Generate all combinations of 3 from A samples
  a_triplets <- combn(a_samples, 3, simplify = FALSE)
  
  results <- lapply(a_triplets, function(triplet) {
    a_species <- pool_species(df, triplet)
    
    all_species <- unique(c(b_species, a_species))
    to_pa <- function(species_list, all_sp) as.numeric(all_sp %in% species_list)
    b_pa <- to_pa(b_species, all_species)
    a_pa <- to_pa(a_species, all_species)
    
    jaccard_sim <- 1 - vegdist(rbind(b_pa, a_pa), method = "jaccard", binary = TRUE)
    similarity <- as.numeric(jaccard_sim)
    
    data.frame(
      Bgroup = b_name,
      Atriplet = paste(triplet, collapse = ","),
      Jaccard = similarity
    )
  })
  
  
  # Combine all results into one df
  do.call(rbind, results)
}

# Example: define your groups
b_samples1 <- c("B12", "B13")
a_samples1 <- c("A2", "A3", "A4", "A10", "A11","A12", "A18", "A19", "A20")

# Run the comparison
jaccard_results <- compare_b_vs_a_triplets(fungi_pa, b_samples1, a_samples1, b_name = "B1", a_name = "A1")

# View top 10 most similar triplets
head(jaccard_results[order(-jaccard_results$Jaccard), ], 10)

# Plot the distribution of Jaccard similarity by A triplet
ggplot(jaccard_results, aes(x = reorder(Atriplet, Jaccard), y = Jaccard)) +
  geom_point(color = "blue") +
  coord_flip() +
  labs(title = "Jaccard similarity between B group and A triplets",
       x = "A triplet samples",
       y = "Jaccard similarity") +
  theme_minimal() +
  theme(
    axis.ticks.y = element_blank(),
    axis.text.y = element_blank()
  )

#-------------------------
# Can emf be monitored using soil eDNA
#--------------------------

#here we need to compare the root, rhizo and soil communities.
#earlier box plots showed that the richness of the roots was lowest.
#redo that and look at community

